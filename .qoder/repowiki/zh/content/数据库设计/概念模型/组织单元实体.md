# 组织单元实体

<cite>
**本文档引用的文件**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs)
- [OrganizationConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/OrganizationConfiguration.cs)
- [20251227093819_InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs)
- [Employee.cs](file://Backend/Hrevolve.Domain/Employees/Employee.cs)
- [JobHistory.cs](file://Backend/Hrevolve.Domain/Employees/JobHistory.cs)
- [DatabaseDesign.drawio](file://Design/DatabaseDesign.drawio)
</cite>

## 目录
1. [引言](#引言)
2. [核心属性详解](#核心属性详解)
3. [双重查询优化机制](#双重查询优化机制)
4. [与员工的1:N关系](#与员工的1n关系)
5. [递归层级关系](#递归层级关系)
6. [实体关系图](#实体关系图)

## 引言
组织单元实体（OrganizationUnit）是人力资源管理系统中的核心组成部分，用于实现灵活的树状组织架构。该实体采用邻接表模型（Adjacency List Model）与路径枚举模型（Path Enumeration Model）相结合的设计，既保证了数据结构的简洁性，又实现了高效的层级查询性能。组织单元支持公司、事业部、部门、团队和小组等多种类型，并通过ParentId和Path字段维护其层级关系。

**Section sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L1-L108)
- [DatabaseDesign.drawio](file://Design/DatabaseDesign.drawio)

## 核心属性详解
组织单元实体包含多个关键属性，每个属性在组织架构管理中扮演着重要角色。

### Id、Name、Code
- **Id**: 唯一标识符，作为主键使用，确保每个组织单元的唯一性。
- **Name**: 组织单元的名称，用于在用户界面中显示，便于用户识别。
- **Code**: 组织单元的编码，通常用于系统内部引用和数据交换，具有唯一性约束。

### ParentId
ParentId字段是实现邻接表模型的核心。它存储了当前组织单元的父级组织单元的Id，通过外键约束与同一表的Id字段关联。当ParentId为null时，表示该组织单元为根节点（如公司总部）。这种设计使得组织架构的增删改操作变得简单直接。

### Path
Path字段是路径枚举模型的关键。它存储了从根节点到当前节点的完整路径，格式为"/父级Id/当前Id/"。例如，一个Id为23的部门，其父级Id为5，祖父级Id为1，则其Path为"/1/5/23/"。Path字段支持高效的子树查询，通过LIKE操作即可快速检索出所有子节点。

### Level
Level字段表示当前组织单元在树状结构中的层级深度。根节点的Level为0，其子节点为1，依此类推。该字段在组织架构的可视化展示和权限控制中具有重要作用。

### 其他属性
- **Type**: 枚举类型，定义了组织单元的类别（公司、事业部、部门、团队、小组）。
- **IsActive**: 布尔值，表示组织单元是否处于激活状态。
- **ManagerId**: 指向负责该组织单元的员工Id，实现组织与人员的关联。

**Section sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L11-L38)
- [OrganizationConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/OrganizationConfiguration.cs#L13-L30)

## 双重查询优化机制
组织单元实体通过结合邻接表模型和路径枚举模型，实现了查询性能的双重优化。

### 邻接表模型的优势与局限
邻接表模型通过ParentId字段直接存储父子关系，使得插入、更新和删除操作非常高效。然而，传统的邻接表模型在查询子树时需要递归操作，性能较差。例如，要查询某个部门的所有子部门，需要多次查询数据库。

### 路径枚举模型的优化
路径枚举模型通过Path字段存储完整路径，解决了邻接表模型的查询瓶颈。利用数据库的LIKE操作，可以一次性查询出所有子节点。例如，要查询Path为"/1/5/"的所有子节点，只需执行`WHERE Path LIKE '/1/5/%'`。

### 索引策略
为了进一步提升查询性能，系统在关键字段上建立了复合索引：
- `(TenantId, ParentId)`: 优化基于租户和父级的查询。
- `(TenantId, Path)`: 优化基于租户和路径的子树查询。

这种双重模型的设计，既保持了邻接表模型的写入效率，又获得了路径枚举模型的读取性能，实现了最佳的平衡。

```mermaid
erDiagram
ORGANIZATION_UNIT ||--o{ ORGANIZATION_UNIT : "Parent-Child"
ORGANIZATION_UNIT ||--o{ EMPLOYEE : "Department-Employee"
ORGANIZATION_UNIT {
string Id PK
string Name
string Code
string? Description
string? ParentId FK
string Path
int Level
int SortOrder
string Type
bool IsActive
string? ManagerId FK
}
EMPLOYEE {
string Id PK
string EmployeeNumber
string FirstName
string LastName
string? Email
string? Phone
string Status
string? DirectManagerId FK
string OrganizationUnitId FK
}
```

**Diagram sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L9-L108)
- [Employee.cs](file://Backend/Hrevolve.Domain/Employees/Employee.cs#L6-L137)

**Section sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L66-L78)
- [OrganizationConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/OrganizationConfiguration.cs#L36-L37)
- [20251227093819_InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs#L174-L175)

## 与员工的1:N关系
组织单元与员工之间存在典型的1:N（一对多）关系，即一个组织单元可以包含多名员工，而每名员工只能归属于一个组织单元。

### 实现方式
这种关系在员工实体（Employee）中通过`OrganizationUnitId`外键实现。在数据库迁移文件中，可以看到明确的外键约束：
```csharp
table.ForeignKey(
    name: "FK_Employees_OrganizationUnits_OrganizationUnitId",
    column: x => x.OrganizationUnitId,
    principalTable: "OrganizationUnits",
    principalColumn: "Id",
    onDelete: ReferentialAction.Restrict);
```

### 业务意义
这种设计反映了企业组织架构的基本原则：员工被分配到具体的部门或团队中。通过这种关系，系统可以轻松实现：
- 按部门统计员工数量
- 查询某个部门的所有员工
- 为部门负责人分配管理权限

### 职位历史的补充
值得注意的是，员工的部门归属并非静态的。通过JobHistory实体，系统实现了SCD Type 2（缓慢变化维度类型2）的历史追踪。每次员工调动部门时，都会创建一条新的JobHistory记录，并设置有效日期范围，从而支持任意时间点的组织架构查询。

**Section sources**
- [Employee.cs](file://Backend/Hrevolve.Domain/Employees/Employee.cs#L8-L137)
- [JobHistory.cs](file://Backend/Hrevolve.Domain/Employees/JobHistory.cs#L9-L124)
- [20251227093819_InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs#L41-L71)

## 递归层级关系
组织单元实体的自引用关系构成了树状结构的基础，支持无限层级的组织架构。

### 自引用实现
在OrganizationUnit类中，通过以下两个属性实现自引用：
```csharp
public Guid? ParentId { get; private set; }
public OrganizationUnit? Parent { get; private set; }
private readonly List<OrganizationUnit> _children = [];
public IReadOnlyCollection<OrganizationUnit> Children => _children.AsReadOnly();
```
ParentId是外键，指向同一表中的Id；Parent是导航属性，用于访问父级对象；Children是子级集合，用于访问所有子级对象。

### 层级操作
实体提供了`UpdatePath`方法，确保在创建或移动组织单元时，Path和Level字段能够自动更新：
```csharp
public void UpdatePath(OrganizationUnit? parent)
{
    if (parent is null)
    {
        Path = $"/{Id}/";
        Level = 0;
    }
    else
    {
        Path = $"{parent.Path}{Id}/";
        Level = parent.Level + 1;
    }
}
```
这种方法保证了数据的一致性，避免了手动维护路径的错误。

### 层级查询
为了方便层级判断，实体提供了两个实用方法：
- `IsAncestorOf`: 判断当前单元是否为指定单元的上级
- `IsDescendantOf`: 判断当前单元是否为指定单元的下级

这些方法利用Path字段的前缀匹配特性，实现了高效的层级关系判断。

**Section sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L14-L15)
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L66-L78)
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L92-L97)

## 实体关系图
以下ER图展示了组织单元实体与其他相关实体的关系：

```mermaid
erDiagram
ORGANIZATION_UNIT ||--o{ ORGANIZATION_UNIT : "Parent-Child"
ORGANIZATION_UNIT ||--o{ EMPLOYEE : "Department-Employee"
ORGANIZATION_UNIT ||--o{ POSITION : "Department-Position"
EMPLOYEE }|--|| JOB_HISTORY : "Employee-JobHistory"
ORGANIZATION_UNIT {
string Id PK
string Name
string Code
string? Description
string? ParentId FK
string Path
int Level
int SortOrder
string Type
bool IsActive
string? ManagerId FK
}
EMPLOYEE {
string Id PK
string EmployeeNumber
string FirstName
string LastName
string? Email
string? Phone
string Status
string? DirectManagerId FK
string OrganizationUnitId FK
}
POSITION {
string Id PK
string Name
string Code
string OrganizationUnitId FK
decimal? SalaryRangeMin
decimal? SalaryRangeMax
}
JOB_HISTORY {
string Id PK
string EmployeeId FK
string PositionId FK
string DepartmentId FK
DateOnly EffectiveStartDate
DateOnly EffectiveEndDate
decimal BaseSalary
}
```

**Diagram sources**
- [OrganizationUnit.cs](file://Backend/Hrevolve.Domain/Organizations/OrganizationUnit.cs#L9-L108)
- [Employee.cs](file://Backend/Hrevolve.Domain/Employees/Employee.cs#L6-L137)
- [Position.cs](file://Backend/Hrevolve.Domain/Organizations/Position.cs)
- [JobHistory.cs](file://Backend/Hrevolve.Domain/Employees/JobHistory.cs#L9-L124)

**Section sources**
- [DatabaseDesign.drawio](file://Design/DatabaseDesign.drawio)
- [OrganizationConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/OrganizationConfiguration.cs#L39-L43)
- [20251227093819_InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs#L167-L180)