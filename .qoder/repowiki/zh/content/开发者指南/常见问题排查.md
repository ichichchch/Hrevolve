# 常见问题排查

<cite>
**本文档引用文件**  
- [Program.cs](file://Backend/Hrevolve.Web/Program.cs)
- [TenantMiddleware.cs](file://Backend/Hrevolve.Web/Middleware/TenantMiddleware.cs)
- [ITenantContext.cs](file://Backend/Hrevolve.Shared/MultiTenancy/ITenantContext.cs)
- [TenantResolver.cs](file://Backend/Hrevolve.Infrastructure/MultiTenancy/TenantResolver.cs)
- [DbInitializer.cs](file://Backend/Hrevolve.Infrastructure/Persistence/DbInitializer.cs)
- [TenantConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/TenantConfiguration.cs)
- [InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs)
- [LoginCommand.cs](file://Backend/Hrevolve.Application/Identity/Commands/LoginCommand.cs)
- [AuthController.cs](file://Backend/Hrevolve.Web/Controllers/AuthController.cs)
- [appsettings.json](file://Backend/Hrevolve.Web/appsettings.json)
- [fix-types.sh](file://Frontend/hrevolve-web/fix-types.sh)
- [TYPE_FIXES.md](file://Frontend/hrevolve-web/TYPE_FIXES.md)
- [vite.config.ts](file://Frontend/hrevolve-web/vite.config.ts)
</cite>

## 目录
1. [数据库迁移失败（EF Core外键冲突）](#数据库迁移失败ef-core外键冲突)
2. [JWT认证失败](#jwt认证失败)
3. [跨域请求被拒](#跨域请求被拒)
4. [多租户数据隔离失效](#多租户数据隔离失效)
5. [前端构建报错](#前端构建报错)

## 数据库迁移失败（EF Core外键冲突）

当执行 `dotnet ef database update` 时出现外键约束冲突，通常是由于种子数据（Seed Data）的插入顺序或实体配置问题导致。

### 检查Configuration类

确保实体配置类（位于 `Backend/Hrevolve.Infrastructure/Persistence/Configurations`）正确设置了外键关系。例如，`TenantConfiguration.cs` 正确配置了租户表：

```csharp
builder.Property(t => t.Settings)
    .HasConversion(
        v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
        v => JsonSerializer.Deserialize<TenantSettings>(v, (JsonSerializerOptions?)null) ?? new TenantSettings())
    .HasMaxLength(2000);
```

检查所有 `IEntityTypeConfiguration<T>` 实现，确保：
- 外键字段类型与主键一致（如 `Guid`）
- 使用 `HasForeignKey` 和 `HasPrincipalKey` 明确指定关系
- 删除行为（`onDelete`）设置合理（如 `Restrict` 或 `Cascade`）

**Section sources**
- [TenantConfiguration.cs](file://Backend/Hrevolve.Infrastructure/Persistence/Configurations/TenantConfiguration.cs#L1-L56)

### 检查种子数据

种子数据的插入顺序必须遵循外键依赖关系。查看 `DbInitializer.cs` 中的 `SeedAsync` 方法：

```csharp
await SeedTenantsAsync();
await context.SaveChangesAsync(); // 先保存租户

await SeedRolesAsync();
await context.SaveChangesAsync(); // 保存角色

await SeedUsersAsync();
await context.SaveChangesAsync(); // 保存用户
```

确保：
1. 主表（如 `Tenants`）先于从表（如 `Users`）插入
2. 在 `SaveChangesAsync` 后再插入依赖该记录的其他数据
3. 外键值（如 `tenantId`）正确引用已存在的主键

**Section sources**
- [DbInitializer.cs](file://Backend/Hrevolve.Infrastructure/Persistence/DbInitializer.cs#L30-L44)

### 验证迁移脚本

检查 `Migrations` 目录下的 `.cs` 文件（如 `20251227093819_InitialCreate.cs`），确认外键约束是否正确生成：

```csharp
migrationBuilder.CreateTable(
    name: "Users",
    columns: table => new { /* ... */ },
    constraints: table =>
    {
        table.PrimaryKey("PK_Users", x => x.Id);
    });

migrationBuilder.CreateTable(
    name: "Employees",
    columns: table => new { /* ... */ },
    constraints: table =>
    {
        table.PrimaryKey("PK_Employees", x => x.Id);
        table.ForeignKey(
            name: "FK_Employees_Users_UserId",
            column: x => x.UserId,
            principalTable: "Users",
            principalColumn: "Id",
            onDelete: ReferentialAction.Restrict);
    });
```

**Section sources**
- [InitialCreate.cs](file://Backend/Hrevolve.Infrastructure/Migrations/20251227093819_InitialCreate.cs#L367-L366)

## JWT认证失败

JWT认证失败可能由Token生成逻辑、过期时间或前端存储问题引起。

### 检查Token生成逻辑

在 `LoginCommand.cs` 的 `GenerateJwtToken` 方法中，确保：
- 签名密钥（Key）与配置一致
- 发行者（Issuer）和受众（Audience）正确
- 包含必要的声明（Claims），如 `tenant_id`

```csharp
var claims = new List<Claim>
{
    new(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
    new("tenant_id", user.TenantId.ToString()),
    // ...
};
```

**Section sources**
- [LoginCommand.cs](file://Backend/Hrevolve.Application/Identity/Commands/LoginCommand.cs#L128-L162)

### 检查过期时间

在 `appsettings.json` 中验证JWT配置：

```json
"Jwt": {
  "Key": "your-256-bit-secret-key-here-must-be-at-least-32-characters",
  "Issuer": "https://hrevolve.local",
  "Audience": "https://hrevolve.local"
}
```

在 `Program.cs` 中，`TokenValidationParameters` 设置了 `ClockSkew = TimeSpan.Zero`，确保时间偏差最小化。

```csharp
options.TokenValidationParameters = new TokenValidationParameters
{
    ValidateLifetime = true,
    ClockSkew = TimeSpan.Zero
};
```

**Section sources**
- [appsettings.json](file://Backend/Hrevolve.Web/appsettings.json#L6-L10)
- [Program.cs](file://Backend/Hrevolve.Web/Program.cs#L75-L85)

### 检查前端存储方式

前端应将Token存储在 `localStorage` 或 `sessionStorage`，并在请求头中正确设置：

```typescript
// api/request.ts
axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
```

使用浏览器开发者工具检查：
- `localStorage` 中是否存在 `access_token`
- 请求头 `Authorization` 是否为 `Bearer <token>`
- Token是否已过期（通过JWT解码工具验证）

**Section sources**
- [AuthController.cs](file://Backend/Hrevolve.Web/Controllers/AuthController.cs#L17-L31)

## 跨域请求被拒

跨域请求被拒通常由CORS策略配置不当或预检请求处理问题导致。

### 验证CORS策略配置

在 `Program.cs` 中，CORS策略已配置为允许所有来源：

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});
```

并在中间件管道中启用：

```csharp
app.UseCors("AllowAll");
```

**Section sources**
- [Program.cs](file://Backend/Hrevolve.Web/Program.cs#L91-L98)

### 预检请求处理

确保 `UseCors` 在 `UseAuthentication` 和 `UseAuthorization` 之前调用，以便预检请求（OPTIONS）能被正确处理。

```csharp
app.UseCors("AllowAll");
app.UseAuthentication();
app.UseAuthorization();
```

前端 `vite.config.ts` 配置了代理，避免开发环境跨域问题：

```typescript
server: {
  proxy: {
    '/api': {
      target: 'https://localhost:5225',
      changeOrigin: true,
    },
  },
}
```

**Section sources**
- [Program.cs](file://Backend/Hrevolve.Web/Program.cs#L131-L132)
- [vite.config.ts](file://Frontend/hrevolve-web/vite.config.ts#L14-L19)

## 多租户数据隔离失效

多租户数据隔离失效通常是由于 `TenantMiddleware` 未正确设置 `ITenantContext` 导致。

### 确认TenantMiddleware设置

`TenantMiddleware` 从JWT中提取 `tenant_id` 并设置上下文：

```csharp
var tenantIdClaim = context.User.FindFirst("tenant_id")?.Value;
if (!string.IsNullOrEmpty(tenantIdClaim) && Guid.TryParse(tenantIdClaim, out var tenantId))
{
    var tenantInfo = await tenantResolver.GetByIdAsync(tenantId);
    if (tenantInfo != null && tenantInfo.IsActive)
    {
        tenantContextAccessor.TenantContext = new TenantContext(tenantInfo.Id, tenantInfo.Code);
    }
}
```

**Section sources**
- [TenantMiddleware.cs](file://Backend/Hrevolve.Web/Middleware/TenantMiddleware.cs#L34-L45)

### 确认ITenantContext实现

`ITenantContextAccessor` 使用 `AsyncLocal` 存储当前租户上下文：

```csharp
public class TenantContextAccessor : ITenantContextAccessor
{
    private static readonly AsyncLocal<TenantContextHolder> _tenantContextCurrent = new();
    public ITenantContext? TenantContext
    {
        get => _tenantContextCurrent.Value?.Context;
        set { /* ... */ }
    }
}
```

**Section sources**
- [ITenantContext.cs](file://Backend/Hrevolve.Shared/MultiTenancy/ITenantContext.cs#L54-L74)

### 验证中间件顺序

在 `Program.cs` 中，`TenantMiddleware` 必须在 `UseAuthentication` 之后，以便从JWT获取租户ID：

```csharp
app.UseAuthentication();
app.UseAuthorization();
app.UseMiddleware<TenantMiddleware>();
```

**Section sources**
- [Program.cs](file://Backend/Hrevolve.Web/Program.cs#L146-L150)

## 前端构建报错

前端构建报错主要涉及TypeScript类型错误或Vite打包异常。

### TypeScript类型错误

根据 `TYPE_FIXES.md`，常见错误包括：
- 字段名不匹配（如 `serialNumber` vs `deviceSerial`）
- API返回类型与期望类型不符（如 `PageResponse` vs `Array`）
- 枚举值大小写不一致

### Vite打包异常

检查 `vite.config.ts` 中的插件和别名配置是否正确：

```typescript
resolve: {
  alias: {
    '@': fileURLToPath(new URL('./src', import.meta.url)),
  },
},
```

### fix-types.sh脚本使用说明

运行 `fix-types.sh` 脚本快速修复常见类型错误：

```bash
cd Frontend/hrevolve-web
./fix-types.sh
```

该脚本将：
1. 修复 `Schedule` 视图的 `PageResponse` 问题
2. 修复 `Expense`、`Insurance`、`Tax` 等模块的字段名问题
3. 修复 `Settings` 相关视图

运行后执行 `npm run build` 验证：

```bash
npm run build
```

**Section sources**
- [fix-types.sh](file://Frontend/hrevolve-web/fix-types.sh#L1-L22)
- [TYPE_FIXES.md](file://Frontend/hrevolve-web/TYPE_FIXES.md#L1-L74)